## 📌 GitLab CI/CD 자동화는 홈 랩 환경에서 어떤 이점을 제공하는가?
 GitLab CI/CD 자동화는 Docker Compose 및 Kubernetes 프로젝트 배포, Terraform을 사용한 인프라 구성 및 프로비저닝과 같은 작업을 <mark>완전히 자동화된 파이프라인으로 간소화하여 시간 절약과 효율성 향상</mark>을 가능하게 합니다. 


## 💡 GitLab CI/CD를 통해 얻을 수 있는 학습 기회는 무엇인가?
 CI/CD(지속적 통합, 배포, 전달)의 개념을 무료로 배우고 구현할 수 있으며, 이는 애플리케이션을 더 빠르고 안전하며 안정적으로 구축하고 배포하는 데 필수적인 기술입니다. 


GitLab CI/CD를 활용하여 **Docker, Kubernetes, Terraform** 등을 이용한 **완전 자동화된 워크플로우**를 구축하는 실용적인 방법을 제시합니다. 이 콘텐츠는 단순히 시간을 절약하는 것을 넘어, **지속적 통합/배포(CI/CD)**의 핵심 개념을 이해하고, **보안성과 신뢰성**을 높이는 자동화 파이프라인을 직접 구축하는 구체적인 가이드를 제공합니다. 개인 프로젝트부터 인프라 프로비저닝까지, **Git 기반의 자동화**를 통해 IT 운영 효율을 극대화하고 싶은 분들에게 강력히 추천합니다.
## 1. GitLab CI/CD를 활용한 자동화 워크플로우 소개 및 CI/CD 개념 설명 


### 1.1. GitLab CI/CD를 활용한 홈 랩 자동화 소개 
![image]()
1. **자동화 목표**: GitLab CI/CD를 사용하여 **워크플로우를 간소화**하고 **완전히 자동화된 파이프라인**을 구축하는 방법을 시연합니다. 
2. **자동화 범위**: Docker Compose 및 Kubernetes 프로젝트 배포, Terraform을 사용한 인프라 구성 및 프로비저닝 등을 자동화합니다. 
3. **CI/CD의 중요성**: 이는 단순히 시간을 절약하는 것을 넘어, **지속적 통합(CI), 지속적 배포(CD)**에 대해 학습할 수 있는 기회이며, 애플리케이션을 **더 빠르고, 안전하며, 안정적으로** 구축하고 배포하는 데 필수적인 주제입니다. 
4. **GitLab CI/CD의 장점**: **자체 호스팅 환경**에서 이 기술을 **완전히 무료**로 학습하고 구현할 수 있습니다. 
5. **목표**: 시청자가 자신의 프로젝트에도 GitLab CI/CD를 사용하도록 영감을 주는 것이 목표입니다. 


### 1.2. 스폰서 소개: CheckMK IT 모니터링 플랫폼 
![image]()
1. **CheckMK 소개**: 최근 홈 랩에서 테스트해 본 **포괄적인 IT 모니터링 플랫폼**입니다. 
2. **주요 특징**: 확장 가능하고, 자동화되어 있으며, **2,000개 이상의 GBLV2 라이선스 플러그인**을 통해 다양한 제조사의 거의 모든 네트워크 구성 요소를 모니터링할 수 있습니다. 
3. **커스텀 기능**: 원하는 모든 것을 모니터링하기 위해 **사용자 지정 플러그인**을 작성할 수 있습니다. 
4. **자동화 기능**: **사전 구성된 임계값과 규칙**을 갖춘 **자동 검색(auto-discovery)** 기능을 제공합니다. 
5. **확장성 및 시각화**: 수십만 개의 호스트와 수백만 개의 장치를 모니터링할 수 있을 만큼 **대규모로 확장 가능**하며, **동적 대시보드**와 로그/이벤트 모니터링을 통해 상세한 시각화를 제공합니다. 
6. **알림 기능**: 주의가 필요한 사항에 대해 **알림**을 제공합니다. 
7. **버전**: **무료 및 오픈 소스 버전**이 있어 쉽게 자체 호스팅할 수 있으며, 기업용으로는 엔터프라이즈 클라우드 및 MSP 버전도 제공됩니다. 
8. **개인 사용 사례**: 시연자는 무료 오픈 소스 버전을 Proxmox VM, Docker 컨테이너, SNMP를 사용하는 방화벽의 상태 모니터링에 배포했습니다. 
9. **추가 정보**: CheckMK에 대한 **전용 튜토리얼**을 계획 중이며, 공식 웹사이트 링크는 설명란에 제공됩니다. 


### 1.3. CI/CD 개념 소개 
1. **CI/CD의 정의**: CI/CD가 실제로 무엇을 의미하는지, 일반적인 구성 요소와 존재하는 솔루션을 이해하여 GitLab이 이 큰 그림에 어떻게 부합하는지 알아봅니다. 


#### 1.3.1. CI (Continuous Integration, 지속적 통합) 
![image]()
1. **정의**: 애자일 소프트웨어 개발 관행으로, 코드 변경 사항에 대해 **자동화된 빌드와 테스트**를 실행하여 소프트웨어 개발 수명 주기 초기에 통합 문제를 감지하는 데 도움을 줍니다. 
2. **중요성**: 여러 개발자가 단일 프로젝트에서 작업하고 공유 리포지토리에 작업을 병합할 때 특히 중요합니다. 
3. **자동 검증**: 코드 변경 사항이 병합되기 전에 **프로그래밍 또는 스타일 오류**에 대해 자동으로 확인되도록 할 수 있으며, 이는 **린팅(linting)**이라고도 합니다. 
4. **이점**: 세미콜론 누락이나 Python의 잘못된 들여쓰기 수준과 같은 오류를 **조기에 감지**하여 코드의 전반적인 품질을 향상시킵니다. 


#### 1.3.2. CD (Continuous Deployment/Delivery, 지속적 배포/전달) 
![image]()
1. **정의**: CI 자동화에 의해 테스트 및 검증된 새 변경 사항이 있을 때, CD 자동화가 **수동 개입 없이** 인프라에 즉시 배포할 수 있음을 의미합니다. 
2. **구분**: 배포(Deployment)와 전달(Delivery)은 별개의 프로세스이지만, 단순화를 위해 배포 프로세스를 간소화하는 **단일 단계**로 볼 수 있습니다. 
3. **효율성**: 수동 개입을 줄여 **실수 가능성을 낮추고** 배포 프로세스의 효율성을 높입니다. 


#### 1.3.3. CI/CD 도구 및 GitLab의 위치 
![image]()
1. **DevOps의 핵심**: CI/CD 개념 전체는 **DevOps의 필수적인 부분**입니다. 
2. **기존 도구**: Jenkins(단순 CI 서버부터 완전한 CD 허브), Kubernetes 애플리케이션 전용 CD 도구인 Argo CD 등이 있습니다. 
3. **Git 플랫폼 통합**: GitHub, GitLab, Bitbucket과 같은 대형 Git 플랫폼은 CI/CD를 위한 자체 솔루션을 플랫폼에 직접 구축했습니다. 
4. **GitLab CI/CD의 특징**: **무료부터 프리미엄, 얼티밋까지 모든 티어에서 완전히 사용 가능**하며, gitlab.com 클라우드 플랫폼과 **자체 관리형 장치** 모두에서 실행될 수 있어 개인 정보 보호 및 로컬 배포에 유용합니다. 


### 1.4. GitLab CI/CD 사용 시작하기 
![image]()
1. **사용 편의성**: **타사 프로그램이나 도구를 설치할 필요 없이** 기존 GitLab 리포지토리에서 바로 사용할 수 있습니다. 
2. **자체 호스팅**: 자체 호스팅된 GitLab 인스턴스 배포에 대한 전체 튜토리얼 링크가 설명란에 제공됩니다. 


## 2. GitLab CI/CD의 기본 구성 요소: .gitlab-ci.yml 및 Runner 


### 2.1. CI/CD 활성화 및 Runner 개념 이해 
![image]()
1. **활성화 방법**: 프로젝트에서 GitLab CI/CD를 활성화하려면 .gitlab-ci.yml 파일을 생성하여 모든 지침과 설정을 추가하고, 프로젝트에 대한 **GitLab Runner를 찾거나 생성**해야 합니다. 
2. **Runner의 정의**: Runner는 CI/CD 파이프라인에서 정의한 작업을 **실행하는 에이전트**입니다. 
3. **실행 위치**: 코드 검증, 테스트 또는 배포 프로세스가 실제로 실행되는 곳입니다. 
4. **Runner 유형**: 간단한 Linux, Windows, Mac OS 머신부터 Proxmox와 같은 하이퍼바이저에서 실행되는 VM, 또는 **Docker 컨테이너** 내에 배포될 수도 있습니다. 
5. **Runner 배포 유연성**: Runner 배포 방식은 전적으로 사용자에게 달려 있으며, 필요한 만큼 **다양한 GitLab Runner 플릿**을 배포할 수 있습니다. 


### 2.2. Runner 환경 제어 및 태그 사용 
![image]()
1. **환경 제어의 필요성**: 실행하려는 자동화 파이프라인 중 일부는 **모든 환경, 운영 체제 또는 기술에서 작동하지 않을 수** 있습니다. 
2. **Docker in Docker 제약**: 소스 코드에서 Docker 컨테이너 이미지를 자동으로 빌드하려는 경우, Runner 자체가 Docker 컨테이너 내에서 실행되면 성능이 좋지 않습니다 (Docker in Docker). 
3. **특정 환경 Runner**:
  1. Docker 이미지 빌드를 위해 **별도의 Runner를 VM에 설치**할 수 있습니다. 
  2. ARM 인프라용 컨테이너 이미지를 빌드하는 경우, x86 아키텍처에서는 잘 작동하지 않으므로 **Raspberry Pi와 같은 곳에 다른 GitLab Runner를 설치**하여 더 빠르게 ARM 이미지를 빌드할 수 있습니다. 
4. **태그 사용**: 이러한 워크플로우에서는 **태그(tags)**를 사용하여 자동화 파이프라인에서 특정 작업을 위해 필요한 인프라를 **명시적으로 사용**하도록 제어할 수 있습니다. 


### 2.3. GitLab Runner 배포 예시 (Docker Compose) 
![image]()
1. **튜토리얼 범위**: 이 튜토리얼에서는 **Docker Compose 프로젝트에 GitLab Runner를 배포**하는 방법을 보여줄 예정이며, 이는 시연자가 홈 랩에서 사용하는 방식입니다. 
2. **배포 조정**: Runner 설정은 사용하려는 환경에 따라 달라지므로, 선호되는 배포 방식이 아닐 수 있음을 유념해야 합니다. 
3. **실습 시작**: 자체 호스팅된 GitLab 플랫폼으로 이동하여 새 Runner를 생성하는 과정을 시작합니다. 


## 3. GitLab Runner 등록 및 구성 


### 3.1. Runner 등록 수준 결정 
![image]()
1. **등록 수준**: Runner는 세 가지 수준에서 사용할 수 있습니다. 
  1. **단일 Git 리포지토리용**: 특정 리포지토리에서만 사용됩니다. 
  2. **그룹용**: 해당 그룹에 연결된 모든 리포지토리에서 사용할 수 있습니다. 
  3. **인스턴스 Runner**: 전체 GitLab 인스턴스에서 사용 가능합니다. 
2. **권장 사항**: 시연자는 **인스턴스 Runner** 생성을 권장하는데, 이렇게 하면 생성된 **모든 프로젝트와 그룹**에서 Runner를 사용할 수 있기 때문입니다. 


### 3.2. 새 인스턴스 Runner 등록 
![image]()
1. **접근**: 관리 인터페이스에서 **CI/CD** 섹션으로 이동하여 Runner 섹션에서 새 Runner를 등록하고 생성할 수 있습니다. 
2. **등록 절차**: **'새 인스턴스 Runner'**를 클릭하고 Runner에 특정 **태그**를 지정할 수 있습니다. 
3. **태그의 역할**: 태그는 자동화 파이프라인에서 **어떤 Runner를 어떤 유형의 작업에 사용할지 정의**하는 데 사용됩니다. 
4. **태그 미사용 옵션**: 태그를 사용하지 않고 모든 작업에 이 Runner를 사용하려면 **'태그 없는 작업 실행(run untagged jobs)'**을 클릭할 수 있습니다. 
5. **추가 구성**: 보호된 브랜치에서만 Runner를 사용하려는 경우와 같은 **선택적 구성**이 있지만, 일반적으로 다른 설정은 필요하지 않습니다. 
6. **생성**: **'Runner 생성'**을 클릭합니다. 
7. **설치 위치 선택**: Linux, Mac, Windows, Google Cloud 또는 **Docker/Kubernetes와 같은 컨테이너**를 사용할지 선택할 수 있으며, 아래에 설치 방법 지침이 제공됩니다. 
8. **Docker Compose 보일러플레이트 사용**: 시연자는 **Docker Compose를 사용하여 새 GitLab Runner를 추가**하기 위한 보일러플레이트를 만들었으므로, 이를 사용합니다. 
9. **프로젝트 디렉토리 준비**: 모든 비디오 및 프로젝트의 Docker Compose 템플릿을 수집하는 Git 리포지토리로 이동하여 GitLab Runner라는 새 폴더를 만들고 테스트 서버에서 새 디렉토리로 이동합니다. 
10. **파일 생성**: VS Code에서 디렉토리를 열고 compose 파일과 Runner 프로세스가 찾을 수 있는 config 디렉토리를 생성합니다. 
11. **구성 파일 형식**: 구성 파일은 **TOML 형식**으로 작성됩니다. 


### 3.3. Docker Compose 파일 구성 
![image]()
1. **Docker Compose 파일**: 최신 **Alpine GitLab Runner 이미지**를 배포하는 매우 간단한 설정입니다. 
2. **컨테이너 이름 지정**: 컨테이너 이름을 GitLab runner one으로 지정합니다. 
3. **구성 파일 마운트**: Runner 프로세스가 찾을 수 있도록 config.toml 파일을 컨테이너의 파일 시스템에 마운트해야 합니다. 
4. **Docker 소켓 전달**: **Docker 소켓을 전달**해야 합니다. 
5. **Docker 소켓이 필요한 이유**: Runner 자체는 Docker 컨테이너 내에서 실행되지만, 새 자동화 프로세스를 시작할 때 **임시 프로세스를 위한 새 Docker 컨테이너를 생성**하여 모든 자동화 단계를 실행한 후 삭제하기 때문입니다. 
6. **Executor 설정**: 이 프로세스는 config 파일의 executor: docker 설정에 의해 수행됩니다. 
7. **Executor 유형**: 다양한 Executor 유형이 있으며, 시연자는 Docker Executor 예시만 보여줍니다. 
8. **Docker Executor의 이점**: 셸 스크립트와 같은 특정 프로세스를 호출하는 자동화 파이프라인의 경우, **일회성 프로세스(ethereal processes)**에 Docker 컨테이너를 사용하는 것이 가장 좋기 때문에 Docker Executor를 사용하여 새 임시 프로세스를 생성하고 실행 후 종료하는 방식을 사용합니다. 
9. **임시 컨테이너 이미지 정의**: 이 임시 Docker 컨테이너에 사용할 **이미지를 정의**할 수 있습니다. 
  1. **기본값**: 기본적으로 docker:latest 이미지가 추가되어 Docker 자동화에 필요한 일부 도구가 포함되어 있습니다. 
  2. **사용자 지정 이미지**: Runner 프로세스가 생성해야 하는 **사용자 지정 Docker 이미지**를 정의할 수도 있으며, 여기에 사용자 지정 도구를 설치하고 프로비저닝할 수 있습니다. 
10. **추가 이미지 정의**: 나중에 프로세스별로 다른 이미지를 정의할 수도 있습니다. 
11. **필수 구성**: 이미지를 지정하지 않는 경우, 컨테이너를 시작하기 전에 **인증**이 필요하며 GitLab 인스턴스가 실행 중인 위치를 알아야 합니다. 


### 3.4. config.toml 파일의 인증 정보 설정 
![image]()
1. **GitLab 인스턴스 주소 변경**: gitlab.acample.com을 시연자가 사용하는 주소(예: git.home.crave.de)로 변경해야 합니다. 
2. **등록 토큰 추가**: **인증**을 위해 **등록 토큰(registration token)**을 추가해야 합니다. 
3. **토큰 위치**: 등록 토큰은 Runner를 등록하고 생성할 때 GitLab 플랫폼에서 확인할 수 있습니다. 
4. **설정 완료**: 토큰을 붙여넣으면 다른 설정은 필요하지 않습니다. 


### 3.5. Runner 시작 및 태그 지정 
![image]()
1. **프로세스 시작**: 테스트 서비스로 이동하여 컨테이너를 시작합니다. 
2. **Runner 확인**: 이미지를 다운로드하고 프로세스를 시작한 후, GitLab 플랫폼으로 돌아가 **'Runner 보기'**를 클릭하면 새 항목이 표시됩니다. 
3. **기존 Runner**: 시연자에게는 이미 사용 중인 **프로덕션 Runner**가 있습니다. 
4. **태그 지정**: 자동화 파이프라인이 어떤 Runner에서 시작될지 알 수 있도록 **태그를 정의**해야 합니다. 
5. **테스트 태그 추가**: 예시로 testing 태그를 생성합니다. 


## 4. .gitlab-ci.yml 파일 구조 및 첫 번째 작업 실행 


### 4.1. .gitlab-ci.yml 파일 생성 및 기본 구조 
![image]()
1. **파일 위치**: GitLab Runner를 배포했으므로, 사용할 **GitLab CI YAML 파일**을 작성할 수 있으며, 이 파일은 **사용하려는 GitLab 리포지토리에 배치**해야 합니다. 
2. **테스트 프로젝트 준비**: Nginx 서버용 Docker Compose 파일과 간단한 테스트 스크립트가 포함된 테스트 프로젝트를 복제하고 VS Code에서 엽니다. 
3. **파일 이름**: 리포지토리에서 .gitlab-ci.yml 파일을 생성합니다. (GitLab이 인식하도록 파일 이름이 JL이 아닌 YML인지 확인해야 합니다.) 
4. **파이프라인 구성 요소**: GitLab 파이프라인은 항상 **작업(jobs)**과 **단계(stages)**로 구성됩니다. 
  1. **Jobs**: 컴파일, 테스트, 배포 코드 실행 명령입니다. 
  2. **Stages**: 이러한 작업을 그룹화하는 방법을 정의하며, 작업 시퀀스를 구성하고 관리하는 방식입니다. 
5. **단계 예시**: CI/CD 프로세스를 다루기 위해 **테스트 단계, 빌드 단계, 배포 단계**와 같이 논리적으로 관련 작업을 그룹화하고 실행 순서를 제어할 수 있습니다. 


### 4.2. YAML 형식 및 작업 정의 
![image]()
1. **형식**: GitLab CI 파일 형식은 **YAML**입니다. 
2. **단계 정의**: 먼저 단계를 정의하며, 시연자는 test, build, deploy 단계를 사용할 예정입니다. 
3. **작업 정의**: 작업은 **키-값 쌍**으로 정의되며, 키는 작업 이름이고 값은 구성 세부 정보가 포함된 YAML 객체입니다. 
4. **필수 요소**: 모든 작업에는 script가 필요하며, 이는 GitLab Runner Executor에 의해 실행되는 명령(셸 스크립트 또는 간단한 터미널 명령)을 포함합니다. 
5. **테스트 스크립트 작업 생성**:
  1. **이름**: test_script로 지정합니다. 
  2. **실행**: scripts 폴더의 test.sh 스크립트를 실행합니다. 
  3. **단계 지정**: 이 작업이 testing 단계에서 실행되도록 정의합니다. 
  4. **스크립트 명령**: 현재 폴더에서 sh 명령을 실행하며, 이 작업은 항상 Git 리포지토리의 **Artifacts**로 시작합니다. 
  5. **Runner 태그 지정**: 이 작업이 testing 태그를 가진 Runner에서 실행되도록 tags 섹션을 추가하고 testing 태그를 정의합니다. 


### 4.3. 파이프라인 트리거 및 실행 확인 
![image]()
1. **트리거 조건**: 코드를 푸시하거나 병합할 때 **기본적으로 자동화 파이프라인이 항상 실행**됩니다. (특정 브랜치에 푸시할 때만 실행되도록 rules를 통해 정의할 수도 있습니다.) 
2. **커밋 및 푸시**: 현재 main 브랜치에 있으므로, 변경 사항을 커밋하고 Git 리포지토리에 푸시합니다. 
3. **파이프라인 확인**: 푸시 후, Git 리포지토리의 **'빌드 파이프라인'** 섹션으로 이동하면 새 프로세스가 실행 중인 것을 볼 수 있습니다. 
4. **단계 시각화**: 실행 중인 프로세스를 클릭하면 작업의 **다른 단계**를 볼 수 있으며, 현재는 testing 단계의 작업 하나만 실행 중입니다. 
5. **로그 확인**: 로그를 확인하면 작업이 성공적으로 완료되었음을 알 수 있습니다. 
6. **Runner 상태 확인**:
  1. Runner가 실행 중인 가상 머신으로 돌아가면 **GitLab Runner 자체는 계속 실행 중**인 것을 확인할 수 있습니다. 
  2. docker ps를 실행하면 임시 컨테이너는 이미 삭제된 것을 볼 수 있습니다. 
7. **임시 컨테이너 실행 과정**: 프로세스가 실행되는 동안, GitLab Runner가 **Docker Executor를 사용하여 새 임시 Docker 컨테이너를 시작**하는 것을 볼 수 있습니다. 
  1. 이 컨테이너 내에서 로그에 표시된 명령들이 실행됩니다. 
  2. **Git 리포지토리 자동 복제** 후, 정의된 **셸 스크립트**가 실행됩니다. 
8. **스크립트 내용**: 스크립트는 "running tests"를 에코하고 현재 OS 및 환경 정보를 출력한 후 종료됩니다. 
9. **출력 확인**: 로그에서 **Alpine Linux**를 사용하고 있으며, 실행된 Terraform 명령(이 예시에서는 Terraform 명령의 출력처럼 보이지만 실제로는 셸 스크립트의 일부)의 정보를 확인할 수 있습니다. 
10. **스크립트 확장 가능성**: 이 스크립트를 확장하여 소프트웨어 빌드, 컨테이너 레지스트리로 푸시 등 원하는 작업을 수행할 수 있습니다. 


## 5. 실용적인 사용 사례: Docker Compose 배포 자동화 


### 5.1. Nginx 배포 자동화 목표 설정 
![image]()
1. **한계점 인식**: 단순한 테스트 스크립트 실행은 "Hello World" 수준이며, 실제 사용법을 가르쳐주지 못합니다. 
2. **프로젝트 구성**: 현재 프로젝트에는 Nginx 컨테이너를 스폰하는 **Docker Compose 파일**과 구성 파일, HTML 콘텐츠(테스트 웹사이트)가 포함되어 있습니다. 
3. **자동화 목표**: GitLab CI를 사용하여 이 Compose 프로젝트를 **테스트 서버에 자동으로 배포**하여, 서버에 수동으로 로그인하여 최신 버전을 다운로드하고 배포하는 과정을 없애는 것입니다. 
4. **일반적인 배포 프로세스**: 시연자는 일반적으로 최신 이미지 태그를 사용하지 않고 특정 버전 태그를 사용하며, Git 리포지토리가 새 이미지 버전으로 업데이트될 때마다 수동으로 서버에 로그인하여 최신 이미지를 풀다운하고 컨테이너를 재시작해야 했습니다. 
5. **자동화 적용**: 이 테스트 프로젝트를 사용하여 Nginx Compose 프로젝트를 테스트 서버에 배포하는 과정을 복제하여 자동화합니다. 


### 5.2. 배포를 위한 준비: CI/CD 변수(Secrets) 관리 
![image]()
1. **새 단계 추가**: 테스트 스크립트 단계는 유지하고, **새로운 **deploy 단계에 새 명령을 정의할 것입니다. 
2. **추가 준비 필요성**: 단순한 테스트 스크립트 호출과 달리, Docker 컨테이너를 배포하려면 구성 파일, 웹사이트, Compose 프로젝트 자체를 **테스트 Linux 서버로 복사**해야 합니다. 
3. **원격 서버 인증**: 자동화 파이프라인이 이 테스트 서버에 인증해야 하므로, Runner 프로세스에 **비밀(secrets) 또는 변수**를 저장해야 합니다. 
4. **GitLab 변수 기능**: GitLab CI/CD에는 이러한 변수 유형을 처리하는 기능이 있으며, 이를 **변수(variables)**라고 합니다. 
5. **변수 정의 방법**:
  1. **작업 내 정의 (권장하지 않음)**: 작업 내에 variables 섹션을 추가하여 일반 텍스트로 미리 정의할 수 있지만, 이는 **자격 증명이나 비밀 정보를 평문으로 노출**하므로 권장되지 않습니다. 
  2. **UI를 통한 정의 (권장)**: **UI에서 변수를 정의**하는 것이 더 나은 방법입니다. 
6. **UI에서 변수 설정**:
  1. Git 프로젝트로 돌아가 **설정 > CI/CD > 변수** 섹션으로 이동합니다. 
  2. 시연자는 이미 **Linux 머신에 인증하기 위해 사용할 개인 SSH 키**를 포함하는 비밀 변수를 생성해 두었습니다. 
  3. **변수 추가**: '변수 추가'를 클릭하고 **가시성 수준**을 정의합니다. 
  4. **가시성 옵션**: 로그에 표시되는 variable, 자격 증명에 유용한 masked 또는 hidden 변수가 있습니다. 
  5. **SSH 키 문제**: SSH 키의 공백 처리가 작동하지 않아 시연자는 가시성 수준을 **'visible'**로 설정했는데, 이는 좋은 방법은 아니지만 작동한 유일한 방법이었습니다. 
  6. **보호된 변수 비활성화**: **'보호된 변수'** 옵션은 반드시 비활성화해야 합니다. 그렇지 않으면 변수가 보호된 브랜치 및 태그에서만 실행될 수 있습니다. 
  7. **변수 추가**: SSH 키 값을 입력하고 변수를 추가합니다. 
  8. **사용**: 이렇게 하면 전체 GitLab 자동화 파이프라인에서 이 변수를 사용할 수 있으며, 평문으로 정의할 필요가 없습니다. 


### 5.3. 배포 작업 정의 및 원격 파일 복사 
![image]()
1. **배포 작업 생성**: Nginx 컨테이너를 배포하기 위한 새 파이프라인 작업을 생성하며, 이름은 deploy_nginx로 지정하고 deploy 단계에 속하도록 합니다. 
2. **스크립트 명령**: 원격 서버에 모든 것을 복사하는 새 명령을 생성합니다. 
3. **재사용 가능한 변수 정의**: 시연자는 원격 호스트, 사용자, 원격 경로와 같은 변수를 정의하여 재사용성을 높입니다. 
  - remote_host: server-test-one.crave.de
  - remote_user: (변수 이름만 언급됨)
  - remote_path: 파일 복사 대상 경로 (/home/user/docker-compose-projects/nginx-test-one) 
4. **변수 사용**: 정의된 변수를 사용하여 원격 서버에 디렉토리를 생성하고 파일을 복사하는 명령을 구성합니다. 
5. **파일 복사 (SCP)**: scp를 사용하여 로컬 배포 디렉토리(deployments/nginx-test-one)의 모든 것을 원격 서버의 remote_path로 복사합니다. 
6. **Docker Compose 실행**: 파일 복사 후, 원격 서버에서 docker compose up 명령을 실행하여 컨테이너를 시작합니다. 
7. **이미지 풀링**: 컨테이너 이미지 버전을 업데이트한 경우, 최신 버전을 다운로드하도록 pull 명령을 먼저 실행하는 것이 좋습니다. 


### 5.4. SSH 인증 및 사전 스크립트 설정 
![image]()
1. **SSH 키 필요성**: Runner가 서버와 성공적으로 SSH 인증을 하려면 **변수에 정의된 SSH 키**가 필요합니다. 
2. before_script 사용: 스크립트 명령이 실행되기 전에 **항상 실행되어야 하는 명령**을 정의하려면 before_script를 사용할 수 있습니다. 
3. **필수 패키지 설치**: 일부 Docker 이미지(임시 Runner 프로세스를 스폰하는 이미지)에는 **OpenSSL 클라이언트**가 없으므로, Alpine Docker 프로세스에서 apk add curl 및 openssh를 사용하여 이러한 도구를 자동으로 설치합니다. 
4. **SSH 키 준비**: SSH 키를 id_rsa로 에코하고 권한을 올바르게 설정하여 나중에 스크립트 명령이 올바른 인증 자격 증명을 갖도록 합니다. 
5. **변경 사항 푸시**: 변경 사항을 커밋하고 푸시하여 새 Runner 프로세스를 호출합니다. 


### 5.5. 배포 파이프라인 실행 및 디버깅 
![image]()
1. **초기 실패**: 파이프라인을 확인하면 **두 단계(test_script 및 deploy_nginx)가 실행**되었고, 첫 번째 단계는 성공했지만 **두 번째 단계가 실패**했음을 알 수 있습니다. 
2. **실패 원인 분석**: 로그를 따라가 보면, OpenSSH 클라이언트 설치는 성공했지만, docker-compose 명령에서 오류가 발생했음을 확인합니다. 
3. **AI 생성 코드 문제**: AI가 생성한 코드가 **구문 오류**를 포함하고 있었는데, 최신 Docker Compose 구문(대시 없음) 대신 구형 구문을 사용했습니다. 
4. **두 번째 시도**: VS Code UI에서 변경 사항을 푸시하여 두 번째 시도를 합니다. 
5. **두 번째 실패 원인**: 두 번째 시도에서도 실패했는데, 이는 **올바른 디렉토리로 이동하는 명령**을 추가하지 않았기 때문입니다. Docker Compose 명령이 현재 디렉토리에서 실행되도록 해야 합니다. 
6. **수정**: -f 플래그를 추가하고 remote_path를 정의하여 Compose 파일이 올바른 디렉토리에서 실행되도록 수정합니다. 
7. **세 번째 시도 성공**: 세 번째 시도에서 **성공**했으며, Runner가 올바른 원격 경로에서 compose.yml 파일을 실행하고, Nginx 이미지를 다운로드한 후 프로젝트를 시작했음을 확인합니다. 


### 5.6. 배포 결과 확인 
![image]()
1. **원격 서버 확인**: GitLab Runner가 자동으로 생성한 Nginx 컨테이너가 원격 서버에 있는지 확인합니다. 
2. **파일 확인**: 프로젝트 디렉토리를 확인하면 파일이 복사되었고, 구성 파일과 HTML 파일이 포함되어 있음을 확인합니다. 
3. **웹 서버 테스트**: 서버에 접속하여 **"test page"** 응답을 확인합니다. 
4. **결론**: 이로써 GitLab CI를 사용하여 **자동화된 파이프라인으로 간단한 Nginx 웹 서버를 배포**하는 방법을 시연했습니다. 


## 6. 고급 사용 사례: 규칙(Rules) 및 Terraform 인프라 자동화 


### 6.1. 홈 랩 서비스 배포 자동화 및 규칙 적용 
![image]()
1. **실제 사용 방식**: 시연자는 홈 랩에서 실행되는 **모든 서비스 또는 애플리케이션 유형에 대해 프로젝트**를 생성하여 CI/CD를 사용합니다. 
2. **홈페이지 컨테이너 예시**: 홈 랩 대시보드 업데이트 시, Compose 파일 오류 확인 및 배포 파이프라인을 실행합니다. 
3. **규칙(Rules) 사용**: rules를 사용하여 **if-else 문**과 유사한 조건을 추가할 수 있습니다. 
  1. **브랜치 기반 배포**: 시연자는 **커밋 브랜치가 **main일 때만 배포 명령을 실행하도록 설정합니다. 테스트 브랜치에 푸시하는 경우 프로덕션 인프라에 배포되어서는 안 되기 때문입니다. 
  2. **파일 변경 기반 배포**: 여러 배포가 정의된 경우, **특정 Compose 파일이 변경될 때만** 배포를 실행하도록 규칙을 정의할 수 있습니다. 
  3. **구성 파일 변경**: 홈 랩 구성 폴더(config 폴더)의 내용이 변경되면 해당 자동화 파이프라인이 새 구성을 원격 서버로 복사합니다. 
4. **이점**: 시연자는 원격 Linux 머신에 로그인할 필요 없이 Git 리포지토리에서 변경하고, 변경 사항이 자동으로 확인 및 배포되도록 합니다. 


### 6.2. Terraform을 사용한 DNS 인프라 관리 자동화 
![image]()
1. **DNS 관리**: 시연자는 **Terraform 파일**에 모든 DNS 항목을 관리합니다. 
2. **DNS 항목 예시**: Proxmox 서버, NAS, 스위치, Kubernetes 배포, 서버 등 모든 항목에 대한 DNS 항목이 Terraform 파일에 정의되어 있습니다. 
3. **GitLab CI 프로세스**:
  1. **비밀 변수**: Terraform 프로젝트에 필요한 **비밀 변수(Terraform 인증용 키)**를 추가합니다. 
  2. **특정 이미지 사용**: 이 자동화 파이프라인을 실행하기 위해 **Open TOFU 이미지**를 사용하도록 지정합니다. (Open TOFU 라이브러리와 명령어가 필요하기 때문입니다.) 
  3. **Terraform 초기화**: 백엔드 초기화를 위해 tofu init 명령을 실행합니다. 
  4. **계획 및 적용**: tofu plan을 실행하여 계획을 출력하고, tofu apply를 실행하여 Terraform 파일의 모든 변경 사항이 인프라에 자동으로 적용되도록 합니다. 
4. **작동 시연**:
  1. 새 DNS 항목(예: test.home.ccrave.de에 IP 10.20.30.245)을 추가하고 Git 리포지토리에 푸시합니다. 
  2. 빌드 파이프라인에서 **두 단계**가 실행됩니다. 
  3. **테스트 단계**: Terraform 상태 파일에 오류가 있는지 **테스트**합니다. (코드에 등호(=)를 빠뜨리는 등의 실수가 있으면 적용 전에 실패하여 인프라에 변경 사항이 적용되는 것을 방지합니다.) 
  4. **성공 확인**: 테스트가 성공하면 로그에서 **새 DNS 항목이 자동으로 추가**되었음을 확인할 수 있습니다. 
  5. **결과 검증**: DNS 서버에 쿼리하면 새로 추가된 IP 주소를 반환받습니다. 
5. **결론**: DNS 서버 업데이트 여부를 신경 쓸 필요 없이, 자동화 파이프라인이 **배경에서 모든 것을 처리**하므로 시간을 크게 절약할 수 있습니다. 

